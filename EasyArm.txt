1. 词条 POSIX
POSIX 是 Portable Operating System Interface 的缩写,表示可移植操作系统接
口,它规定了操作系统应该为应用编程提供的接口标准。

2. Linux 内核的重要特点
Linux 是一个开放自由的操作系统内核,具有一些鲜明的特点:
(1) Linux 是一个一体化内核;
注:
“一体化内核”是也称“宏内核”
,是相对于“微内核”而言的。几乎所有
的嵌入式和实时系统都采用微内核,如 VxWorks、uC/OS-II、PSOS 等。
(2) 可移植性强。尽管 Linus 最初只为在 X86 PC 上实现一个“类 UNIX”,后来随
着加入者的努力,Linux 目前已经成为支持硬件平台最广泛的操作系统;
注:目前已经在 X86、IA64、ARM、MIPS、AVR32、M68K、S390、Blackfin、M32R
等众多架构处理器上运行。
(3) 是一个可裁剪操作系统内核。Linux 极具伸缩性,内核可以任意裁剪,可以大至
几十或者上百兆,可以小至几百 K,运行的设备从超级计算机、大型服务器到
小型嵌入式系统、掌上移动设备或者嵌入式模块,都可以运行;
(4) 模块化。Linux 内核采用模块化设计,很多功能模块都可以编译为模块,可以在
内核运行中动态加载/卸载而无需重启系统;
(5) 网络支持完善。Linux 内核集成了完整的 POSIX 网络协议栈,网络功能完善;
(6) 稳定性强。运行 Linux 的内核的服务器可以做到几年不用复位重启;
4广州致远电子股份有限公司(www.zlg.cn)/广州周立功单片机科技有限公司(www.zlgmcu.com)
(7) 安全性好。Linux 源码开放,由众多黑客参与 Linux 的开发,一旦发现漏洞都能
及时修复;
(8) 支持的设备广泛。Linux 源码中,设备驱动源码占了很大比例,几乎能支持任何
常见设备,无论是很老旧的设备还是最新推出的硬件设备,几乎都能找到 Linux
下的驱动。

3. Linux 内核由 5 个主要子系统组成,分别是:内存管理、进程管理、进程间通信、虚拟
文件系统和网络

进程管理
进程管理负责控制进程对 CPU 的访问,如任务的创建、调度和终止等。任务调度是进
程管理最核心的工作,由 Linux 内核调度器来完成。Linux 内核调度器根据一定算法来选择
最值得运行的进程。


一个进程的可能状态有如下几种:
(1) 运行态——已经获得了资源,并且进程正在被 CPU 执行。进程既可运行在内核
态,也可运行在用户态。
 内核态,内核和驱动所运行时的状态,程序处于特权阶级,能够访问系统的任
何资源,好比社会的统治者。
 用户态,用户程序运行的状态,处于非特权阶级,不能随意访问系统资源,必
须通过驱动程序方可访问,用户态程序可通过系统调用进入内核态。用户态程
序有如社会的被统治者,处于被管理的非特权阶级,只有通过某种途径才能进
入特权阶级。
(2) 就绪态——当系统资源已经可用,但由于前一个进程还没有执行完而释放 CPU,
准备进入运行状态。
(3) 可中断睡眠状态——当进程处于可中断等待状态时,系统不会调度该程序执行。
当系统产生一个中断或者释放了进程正在等待的资源,或者进程收到一个信号,
都可以被唤醒进入就绪状态或者运行态。
(4) 不可中断睡眠状态——处于中断等待状态,但是该进程只能被使用 wake_up()
函数明确唤醒的时候才可进入就绪状态。
(5) 暂停状态——当进程收到 SIGSTOP、SIGSTP、SIGTTIN 或者 SIGTTOU 就会进
入暂停状态,收到 SIGCONT 信号即可进入运行态。
(6) 僵死态——进程已经停止运行,但是其父进程还没有询问其状态。


进程和状态的转换有点抽象,用生活中一个比较接近的例子类比一下,或许能有助于理
解。Linux 内核调度器好比是生产线的主管,而进程则好比是生产线上的工人。主管 24 小
时不间断的工作,工人的工作时间是朝九晚五,其余时间在等待区排队等候。
早上工人到达工厂,还没到 9 点上班时间,工人可以在等待区休息,这个状态可以称之
为“就绪态”
;但是 9 点一到,工人则必须上生产线工作,这个工作状态可称之为“运行态”
;
下午 5 点一到,到了工人下班时间,工人离开生产线又回到等待区排队等候,处于“就绪态”
。
如果工人上班的时候,收到主管的命令,说是“你暂时不用工作了,到休息室休息等待”
,
工人此时的这个状态,可以称之为“暂停”状态,过了一段时间,主管通知工人说是“休息
结束,要准备工作了”
,工人不能直接回生产线岗位,而是必须先到等待区排队等待,轮到
后才上生产线工作。
如果有一天工人精神状态不好,向主管申请要睡觉休息,理由可以是“某种配件不到,
我无法工作”
,也可以是“我就是困了,想睡觉”
,工人最后可能得到两种批准结果:一是主
管批准了,但是附加了一个条件说“等我叫醒你,你必须醒来上班”,然后工人就去享受他
的安稳觉了,工人进入“不可中断睡眠”状态;另一种是主管也批准了,但是附加了另一个
条件,说“在你睡觉的时候,如果配件到了,你就得立马给我起来上班”,工人也去睡觉去
了,但此时工人睡得并不安心,因为这不是一个安稳觉,是“可中断睡眠”
。无论工人睡得
是安稳觉,还是不安稳觉,醒来都不能直接上生产线,而是回到等待区,等待轮值。
还有一种情况,工人干完活到点下班了,但主管对他不闻不问,也不安排新的工作,这
是一种非正常状况,工人进入了“僵死态”。


内存管理
内存管理的主要作用是控制和管理多个进程,使之能够安全的共享主内存区域。当 CPU
提供内存管理单元(MMU)时,内存管理为各进程实现虚拟地址到内存物理地址的转换。
在 32 位系统上, Linux 内核将 4G 空间分为 1G 内核空间(3~4G)和 3G(0~3G)用户空间,
通过内存管理,每个进程都可以使用 3G 的用户空间。



文件系统
Linux 内核支持众多的逻辑文件系统,如 Ext2、Ext3、Ext4、btrfs、NFS、VFAT 等。
VFS 则是 Linux 基于各种逻辑文件系统抽象出的一种内存中的文件系统,隐藏了各种硬件设
备细节,为用户提供统一的操作接口,是用户访问各种不同文件系统和设备时,不用区分具
体的逻辑文件系统。例如,Linux 下硬盘上使用的文件系统通常是 Ext3/4 格式,而 U 盘通常
是 FAT32 格式,但是用户在使用中根本感觉不到差异,也不用区分文件系统的具体差别。
4. 网络接口
Linux 对网络支持相当完善,网络接口提供了对各种网络标准的存取和各种网络硬件的
支持,接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输
协议。网络设备驱动程序负责与硬件设备通讯,每一种可能的硬件设备都有相应的设备驱动
程序。


进程间通信
支持进程间各种通信机制,如管道、命名管道、信号、消息队列、内存共享、信号量和
套接字等。
 管道通常用于具有亲缘关系的父子进程或者兄弟进程间通信,是半双工的,数据只
能往一个方向流动,先入先出,与自来水管很相似。如果双方互通时,需要建立两
个管道。
 命名管道则突破了进程间的亲缘关系限制,即非父子、兄弟进程之间也可相互通信。
 信号是软件中断,用于在多个进程之间传递异步信号。日常生活中信号的例子很多
了,如一对很亲密的哑巴情侣,在很多时候只需要一个简单的眼神,对方就能知道
他(她)需要什么,并做出回应,这个眼神,就是一个“信号”。
 信号能传递的信息有限,而消息队列则正好弥补了这点。例如情侣的一个眼神,对
方可能能知道情侣的需求,但是如果情侣有一大堆需求,仅仅靠一个眼神就比较费
力了。情侣就把自己的需求写在了一张纸条上,递交给对方,对方根据纸条的内容,
逐一满足情侣的需求。
 共享内存常用于不同进程间进行大量数据传递。Linux 下每个进程都有自己的独立
空间,各自都不能直接访问其它进程的空间。好比这对情侣都有自己的小金库,有
时候需要给对方一部分钱用,但他们不能直接相互转账,必须先将前存到他们俩合
开的一个公共账户上面,然后再使用。这个公共账户就是这对情侣的“共享内存”
。
 信号量用于进程同步。只有获得了信号量的进程才可以运行,没有获得信号量的进
程则只能等待。就像十字路口的红绿灯,只有在绿灯亮(获得了绿灯)的时候才能
通行,否则只能等待。
 套接字(Socket)起源于 BSD,也常称“BSD 套接字”
,用于多个进程间通信,可以
基于文件,也可基于网络。Socket 本意是“插座”,套接字设计就是通过某些参数
设定,然后将一个“插座”与另外一个“插座”连接起来。可能还有点抽象,看一
个例子可能就好理解了。把套接字理解为固定电话的插口,现在要打电话出去,必
须要知道打给谁,往哪里打;另外电话另一端必须有人在听才可以通话,否则也不
能打电话。




4.
嵌入式 Linux 是对运行在嵌入式设备上的 Linux 的统称,严格说来,每种不同应用的嵌
入式 Linux 都可以称为是一个发行版。嵌入式 Linux 往往针对于某个特殊领域,专门为实现
某些特定的功能而开发,一般说来,嵌入式 Linux 所运行的程序相对来说比较单一,功能定
位也比较明确,如嵌入式网关、路由器等

将标准 Linux 应用到嵌入式领域,往往是根据实际需要裁减内核,内核一般从几百 K
到几兆字节不等。所使用的文件系统也不是桌面 Linux 这样复杂庞大的软件包,一般也是用
源码或者其它工具定制,文件系统的大小也可以从几兆到几十兆,或者上百兆不等。
Linux 在嵌入式领域的分化,一般是两个方向,小型化和实时化。
小型化一般就是根据需要将不需要的功能和服务去掉,尽可能的减小内核和系统的体积,
以节省硬件资源和成本,如 ETLinux、uLinux、ThinLinux 等。
实时化一般是通过修改源代码,为 Linux 内核增加比校准内核更好的实时性,以满足一
些对实时性有要求的特定领域的应用,如 RTLinux、RTAI 等。

5.
无论最终产品以何种形态出现,在开发阶段,串口和网口几乎是必不可缺的外设接口。
嵌入式 Linux 的默认终端通常是调试串口,系统输出信息通过串口输出,也通过串口接收各
种命令。而网口则常用于数据传输和程序调试,特别是在内核开发阶段以及应用程序开发阶
段,网络几乎也是必须的。

6.
$chmod +x a.sh
$./a.sh
执行 Shell 脚本有多种方式:
(1)点+斜线+文件名,这种方式要求文件必须有可执行权限

7.
交叉编译
由于嵌入式系统资源匮乏,一般不能像 PC 一样安装本地编译器和调试器,不能在本地
编写、编译和调试自身运行的程序,而需借助其它系统如 PC 来完成这些工作,这样的系统
通常被称为宿主机。
宿主机通常是 Linux 系统,并安装交叉编译器、调试器等工具;宿主机也可以是 Windows
系统,安装嵌入式 Linux 集成开发环境。在宿主机上编写和编译代码,通过串口、网口或者
硬件调试器将程序下载到目标系统里面运行

所谓的交叉编译,就是在宿主机平台上使用某种特定的交叉编译器,为某种与宿主机不
同平台的目标系统编译程序,得到的程序在目标系统上运行而非在宿主机本地运行。这里的
平台包含两层含义:一是核心处理器的架构,二是所运行的系统,这样,交叉编译有 3 种情
形:
(1) 目标系统与宿主机处理器相同,运行不同的系统;
(2) 目标系统与宿主机处理器不同,运行相同的系统;
(3) 目标系统与宿主机处理器不同,运行不同的系统


实际上,在 PC 上进行非 Linux 的嵌入式开发,哪怕使用 IDE 集成环境如 Keil、ADS、
Realview,都是交叉编译和调试的过程,只是 IDE 工具隐藏了细节,没有明确提出这个概念
而已。

交叉编译器
交叉编译器是在宿主机上运行的编译器,但是编译后得到的二进制程序却不能在宿主机
上运行,而只能在目标机上运行。交叉编译器命名方式一般遵循“处理器-系统-gcc”这样的
规则,一般通过名称便可以知道交叉编译器的功能。例如下列交叉编译器:
 arm-none-eabi-gcc,
表示目标处理器是 ARM,
不运行操作系统,
仅运行前后台程序;
 arm-uclinuxeabi-gcc,表示目标处理器是 ARM,运行 uClinux 操作系统;
 arm-none-linux-gnueabi-gcc,表示目标处理器是 ARM,运行 Linux 操作系统;
 mips-linux-gnu-gcc,表示目标处理器是 MIPS,运行 Linux 操作系统。
进行 ARM Linux 开发,通常选择 arm-linux-gcc 交叉编译器。ARM-Linux 交叉编译器可
以自行从源代码编译,也可以从第三方获取。在能从第三方获取交叉编译器的情况下,请尽
量采用第三方编译器而不要自行编译,一是编译过程繁琐,不能保证成功,二是就算编译成
功,也不能保证交叉编译器的稳定性,编译器的不稳定性会对后续的开发带来无限隐患。而
第三方提供的交叉编译器通常都经过比较完善的测试,确认是稳定可靠的。


8.
“Vi+Gcc+Make+GDB”这一组“黄
金搭档”
,它们是 Linux 世界编程的经典组合。这个组合的推出,既能替“选择困难症”者
做决定性选择,也能有效防止“病急乱投医”。


对于一些大型程序,在 IDE 环境中编程,或许能带来更多好处,为此,也介绍了
一个在 Linux 世界几乎“无所不能”的 IDE——Eclipse

gcc 主要软件包
cpp C 预处理器
gcc C 编译器
g++ C++编译器
gccbug 创建 BUG 报告的 Shell 脚本
gcov 覆盖测试工具,用于分析程序哪里做优化效果最佳
libgcc GCC 的运行库
libstdc++ 标准 C++库
libsupc++ 提供支持 C++语言的函数库


9. 
64位Ubuntu 16.04搭建嵌入式交叉编译环境arm-linux-gcc过程图解
https://www.linuxidc.com/Linux/2016-12/138771.htm


10.
Board Support Package顾名思义，就是板级支持包，说白了就是最底层底层的驱动+与某种操作系统的接口。
学过单片机或arm的都知道驱动，如果这些驱动能够支持某种操作系统（如linux）运行在这个板子上，
那么就说他是这个操作系统在这个板子上的bsp。比如你编译不同版本嵌入式linux操作系统时，低的版本可能只支持到2410,2440，
高的支持到6410板子以上，通用的linux已经根据一定标准把流行的几种的硬件板子的bsp都做好了，所以不用开发bsp，
但是特殊的板子或者特殊的需求（比如有的功能需要绕开操作系统做到最底层）都需要开发bsp，没有它操作系统运行不了。

BSP相当于硬件驱动，完成初始化、时钟、中断、串口、网络、flash等的设备驱动。
BootLoader用于加载、调试程序。

不同的CPU具有不同的启动方式，其系统外设等均具有较大的差异。CPU上电启动后，并不具有相应的内核启动环境，
需要bootloader先初始化CPU及相应系统外设，加载内核，使之具备内核启动的必要条件。bootloader一般应有下载固化以及加载启动这两个功能，



11.Linux多线程编程c

线程（thread）是包含在进程内部的顺序执行流，是进程中的实际运作单位，也是操作系统能够进行调度的最小单位。一个进程中可以并发多条线程，每条线程并行执行不同的任务。
线程与进的关系
线程与进程的关系可以归结于以下几点：
 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主；
 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该；
 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源；
 进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于资源；
 在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大建或撤消线程时的开销。 建或撤消线程时的开销。 建或撤消线程时的开销。 建或撤消线程时的开销。


POSIX Threads（通常简称为Pthreads）定义了创建和操纵线程的一套API接口，一般用于Unix-like POSIX 系统中（如FreeBSD、GNU/Linux、OpenBSD、Mac OS等系统）

Pthreads接口可以根据功能划分四个组：
 线程管理 线程管理
 互斥量
 条件变量 条件变量
 同步
编写Pthreads多线程程序时源码只需包含pthread.h头文件就可以使用Pthreads库中的所有类型及函数： #include <pthread.h>

LDFLDF += -pthread




pthread_t pthread_self(void); //线程可以通过调用pthread_self()函数来获取自己的ID

int pthread_equal(pthread_t t1, pthread_t t2); //由于pthread_t类型可能是一个结构体，可以使用pthread_equal()来比较两个线程ID是否相等。


int pthread_create(pthread_t *thread, const pthread_attr_t * attr, void*(*start_routine)(void*),void *arg); //创建一个新线程的函数是pthread_create()

参数说明：
 threadthread thread 用指向新创建的 线程用指向新创建的 线程用指向新创建的 线程用指向新创建的 线程用指向新创建的 线程ID ；
 attr attrattr用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 attr attrattr为 NULLNULLNULLNULL，新线程就 使用默认的属性， 使用默认的属性， 使用默认的属性， 使用默认的属性， 13.3.4 13.3.4 节将讨论线程属性的细； 节将讨论线程属性的细； 节将讨论线程属性的细； 节将讨论线程属性的细； 节将讨论线程属性的细； 节将讨论线程属性的细；
 start_routine start_routine start_routinestart_routine start_routine start_routinestart_routine 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， start_routine start_routine start_routinestart_routine start_routine start_routinestart_routine 函数有 一个函数有 一个函数有 一个函数有 一个指向 voidvoid void的指针参数，并有 的指针参数，并有 的指针参数，并有 的指针参数，并有 的指针参数，并有 pthread_crea pthread_crea pthread_crea pthread_crea pthread_crea te 的第四个参数 的第四个参数 的第四个参数 的第四个参数 arg arg指定值，同时 指定值，同时 指定值，同时 start_routine start_routine start_routinestart_routine start_routine start_routinestart_routine 函数返回一个指向 函数返回一个指向 函数返回一个指向 函数返回一个指向 voidvoid void的指针，这个返回值被 的指针，这个返回值被 的指针，这个返回值被 的指针，这个返回值被 的指针，这个返回值被 的指针，这个返回值被 pthread_join pthread_join pthread_join pthread_join pthread_join当做退出 当做退出 当做退出 状态处理， 状态处理， 13.3.3 13.3.3节介绍线程的退出状态； 节介绍线程的退出状态； 节介绍线程的退出状态； 节介绍线程的退出状态； 节介绍线程的退出状态； 节介绍线程的退出状态；
 arg arg为参数 为参数 start_routine start_routine start_routinestart_routine start_routine start_routinestart_routine 指定函数的参。 指定函数的参。 指定函数的参。


void pthread_exit(void* retval);
//调用exit()函数会使整个进程终止，而调用pthread_exit()只会使得调用线程终止，同时在创建的线程的顶层执行return线程会隐式地调用pthread_exit()


连接与分离
线程可以分为分离线程(DETACHED)和非分离线程(JOINABLE)两种：
 分离线程是指线程退出时线程将释放它的资源的线程；
 非分离线程退出后不会立即释放资源，需要另一个线程为它调用pthread_join函数或者进程退出时才会释放资源。
只有非分离线程才是可连接的，而分离线程退出时不会报告线程的退出状态。

int pthread_detach(pthread_t thread); // pthread_detach()函数可以将非分离线程设置为分离线程
pthread_detach(pthread_self());   //线程可以自己来设置分离，也可以由其它线程来设置分离，以下代码线程可设置自身分离


int  pthread_join(pthread_t thread,void** retval); //如果一个线程是非分离线程，那么其它线程可调用pthread_join()函数对非分离线程进行连接

int pthread_attr_init(pthread_attr_t *attr); //函数用于将属性对象使默认值进行初始化，认值进行初始化，
int pthread_attr_destroy(pthread_attr_t *attr);   //销毁属性对象使用 

int pthread_attr_getdetachstate(pthread_attr_t *attr, int* detachstate);  //获取线程状态
int pthread_attr_setdetachstate(pthread_attr_t * attr, int detachestate);  //设置线程状态

int pthread_attr_getstacksize(pthread_attr_t,, size_t*stacksize);
int pthread_attr_setstacksize(pthread_attr_t * attr, size_t stacksize);

int pthread_attr_getdetachstate(pthread_attr_t* attr, int* detachstate);
int pthread_attr_setdetachstate(pthread_attr_t* attr, int detachstate);

12. NFS配置

ls
https://blog.csdn.net/czcdcdsn/article/details/78996412

#/etc/init.d/nfs-kernel-server start    //方法一


在Virtual Host上测试NFS服务
	在Virtual Host 的终端中输入“cd /home/nfs”进入NFS服务的共享目录，然后输入命令“mkdir a b c d”在NFS服务的共享目录下创建a、b、c、d四个空目录，
	
	使用“mkdir -p /mnt/nfs_test”命令创建NFS服务的共享目录的测试挂载点目录，这时使用命令“ls /mnt/nfs_test”查看挂载点目录为空。
	在Virtual Host 的终端中输入“ifconfig eth0 ”查看Virtual Host 的IP地址（当前Virtual Host 的IP为192.168.1.110）。
	在Virtual Host的终端中输入命令“mount -t nfs 192.168.1.110:/home/nfs /mnt/nfs_test -o nolock” ，
	将Virtual Host 上NFS服务共享的目录挂载到Virtual Host 的测试挂载点/mnt/nfs_test上，这时使用命令“ls /mnt/nfs_test”查看挂载点目录，内容与/home/nfs相同



在Target Board的终端中输入命令“mount -t nfs 172.20.4.101:/home/nfs /mnt -o nolock”，
将virtual Host上的NFS共享目录挂载到Target Board的/mnt上。在Target Board的/mnt/目录下可以看到readme.txt文件


steps:

1. arm-fsl-linux-gnueabi-gcc hello.c -o hello
2. sudo cp hello /home/nfs/






13. U-boot
Bootloader 不是嵌入式 Linux 的一部分,但几乎却是嵌入式 Linux 系统不可缺少的组
成部分。当然也有例外,例如支持 XIP 的内核,就可以不需要 Bootloader,这里暂不考虑
这种情形。
Bootloader 的基本功能是引导嵌入式 Linux 运行,通常是先将 Linux 内核加载绕 RAM
指定位置,设置内核启动参数,然后启动 Linux。实际应用中,Bootloader 的功能还包括固
化和更新内核,甚至更新 Bootloader 本身和 Linux 文件系统等,有的 Bootloader 还有硬件
测试功能。
能引导嵌入式 Linux 的 Bootloader 有很多,例如 U-Boot、 Vivi、 Blob 等,其中以 U-Boot
应用最为广泛,本章以 U-Boot 为例进行介绍


Linux 是一个可裁剪的操作系统,伸缩性极强,在资源匮乏的嵌入式领域,也能运行自
如。嵌入式 Linux 是将标准 Linux 经过裁剪后在嵌入式系统中运行的发行版。嵌入式 Linux
功能针对性较强,往往针对于某种特殊应用,如嵌入式网关、路由器或者交换机,或者分布
式数据采集等等。
常见的运行嵌入式 Linux 的处理器有 ARM、 PowerPC、 Blackfin、 MIPS、 M68K 系列等,
其中又以 ARM 最为流行。ARM Linux 是嵌入式 Linux 的一个非常重要的分支,项目主页为
http://www.arm.linux.org.uk



运行嵌入式 Linux 的一般硬件系统架构如图 10.1 所示,以处理器为中心,配备电源系
统、调试串口、以太网接口、存储系统和其它功能接口
其中调试串口和以太网接口在调试阶段通常是必不可少的,所以把它们单独列出来。

运行嵌入式 Linux 的系统,一般都由引导程序、内核以及根文件系统等几部分组成,一般都存放在 Flash 闪存这样的存储介质上

与桌面通用 Linux 一样,嵌入式 Linux 也需要一段引导代码引导其运行,这段引导代码
被称为 Bootloader,在 PC 机上,通常是主板 BIOS,而在嵌入式领域,由于处理器的多样性,
Bootloader 也不尽相同,如 S3C24x0 系列处理器的 vivi,PXA2x0 系列的 Blob,都是比较有
名的 Bootloader,但是这类 Bootloader 主要针对于某系列特定的处理器,通用性较差。通用
性强且使用方便的莫过于 U-Boot 了。
Bootloader 一般存放于能上电自引导的 NOR Flash,对于有 NAND Flash 控制器的处理
器,一般也能从 NAND Flash 引导运行,也可以将 U-Boot 放在 NAND Flash 中。

嵌入式 Linux Bootloader 的基本功能:引导和下载,也可以说嵌入式 Linux Bootloader
的两种运行模式分别是系统引导模式和程序下载模式。
在引导模式下,Bootloader 根据设定的参数直接引导操作系统启动。引导操作系统启动
时 Bootloader 最基本的核心功能。
在程序下载模式下,Bootloader 能够完成内核、根文件系统的固化和更新,甚至实现
Bootloader 的自我更新。至于通过何种方式来完成文件下载和固化,则与处理器以及
Bootloader 的具体实现相关,没有统一的标准,可以通过串口下载,也可以通过以太网下载,
甚至可以通过 USB 接口或者 SD 等接口完成这些功能。
扩展功能,如硬件检测,文件系统支持和文件浏览等,这些是 Bootloader 的附加功能。
但是在很多情况下,这些扩展功能往往能在开发过程中发挥巨大作用,特别是在产品开发初
期的硬件调试阶段,
硬件检测功能往往能带来非常大的便利。对于一个完善易用的 Bootloader,
这些功能也是必要的

U-Boot 全称 Universal Boot Loader,是德国 DENX 软件工程中心 Wolfgang Denk 工程师
维护的一个遵循 GPL 条款的开放源码项目,从 FADSROM、8xxROM、PPCBOOT 逐步发展
演化而来。 U-Boot 既能支持多种处理器包括: PowerPC 系列的处理器、 MIPS、 X86、 ARM、
NIOS、 XScale 等,还能引导 Linux、 BSD、 Solaris、 VxWorks、 LynxOS、 pSOS、 QNX、 RTEMS、
ARTOS 等众多操作系统。
U-Boot 的其源码目录与 Linux 类似,甚至于编译方式也与 Linux 内核相似。U-Boot 的
源码很多都是 Linux 内核源码的简化,特别是驱动部分的源码。


U-Boot 的一些特性:
 开放源码,自由使用;
 支持多种嵌入式操作系统内核,如 Linux、NetBSD、 VxWorks、 QNX、 RTEMS 等;
 支持多个处理器系列,如 PowerPC、ARM、x86、MIPS、XScale;
 可靠性和稳定性都较好;
 支持命令行,有自己的 Shell;
 配置灵活,使用方便;
 支持外设丰富,如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、
RTC、键盘等;
 文档较多,网络技术支持方便。

U-Boot 的功能
U-Boot 是一个通用性强,使用方便的 Bootloader,除了嵌入式 Bootloader 的基本功能之
外,还有很多非常实用的功能,这些功能包括:
 系统引导;
 支持 NFS 挂载、RAMDISK(压缩或非压缩)形式的根文件系统;
 支持 NFS 挂载、从 FLASH 中引导压缩或非压缩系统内核;
 操作系统接口功能强大:可灵活设置、传递多个关键参数给操作系统,适合系统在
不同开发阶段的调试要求与产品发布;
 CRC32 校验,可校验 FLASH 中内核、RAMDISK 镜像文件是否完好;
 提供各种外设的驱动,如串口、FLASH、以太网、LCD、EEPROM、键盘、USB、
PCMCIA、RTC 等;
 上电自检能:可自动检测 SDRAM、FLASH 大小,也能检测外设故障;
 特殊功能:还可支持 XIP 内核引导。



14. 嵌入式 Linux 文件系统
文件组织结构上来说,嵌入式 Linux 文件系统与普通 PC/服务器 Linux 的文件系统是
一样的,只是嵌入式 Linux 文件系统根据产品功能进行过裁剪,在内容多少和体积大小上不
同。进行嵌入式 Linux 产品开发,构建一个合适的文件系统是不可或缺的,可以基于已有文
件系统进行裁剪或者定制,也可以从头开始构建。




15 .编写内核模块
1． 头文件
内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也内核模块需要包含相 关头文件，不同根据功能的差异所也同，但是 同，但是 <linux/module.h<linux/module.h<linux/module.h<linux/module.h <linux/module.h<linux/module.h <linux/module.h >和<linux/init.h><linux/init.h><linux/init.h><linux/init.h> <linux/init.h><linux/init.h> <linux/init.h><linux/init.h> 是必不可少的。 是必不可少的。 是必不可少的。

内核模块需要包含内核相关头文件,不同模块根据功能的差异,所需要的头文件也不相
同,但是<linux/module.h>和<linux/init.h>是必不可少的。



模块的初始化负责注册模块本身。如果一个内核模块没有被注册,则其内部的各种方法
无法被应用程序使用,只有已注册模块的各种方法才能够被应用程序使用并发挥各方法的实
注
际功能。模块并不是内核内部的代码,而是独立于内核之外 [ ] ,通过初始化,能够让内核之
外的代码来替内核完成本应该由内核完成的功能,模块初始化的功能相当于模块与内核之间
衔接的桥梁,告知内核“我进来了,我已经做好准备为您服务了”


static int __init module_init_func(void)
{
初始化代码
}
module_init(module_init_func);



当系统不再需要某个模块,可以卸载这个模块以释放该模块所占用的资源。模块的退出
相当于告知内核“我要离开了,将不再为您服务了”



static void __exit module_exit_func(void)
{
模块退出代码
}
module_exit(module_exit_func);


Linux 系统中的设备可以分为字符设备、块设备和网络设备这 3 类

Linux 系统中的设备可以分为字符设备、块设备和网络设备这 3 类。
字符设备:字符设备是能够像字节流一样被访问的设备,当对字符设备发出读写请求,
相应的 I/O 操作立即发生。 Linux 系统中很多设备都是字符设备,如字符终端、串口、键盘、
鼠标等。在嵌入式 Linux 开发中,接触最多的就是字符设备以及驱动。
块设备:块设备是 Linux 系统中进行 I/O 操作时必须以块为单位进行访问的设备,块设
备能够安装文件系统。块设备驱动会利用一块系统内存作为缓冲区,因此对块设备发出读写
访问,并不一定立即产生硬件 I/O 操作。Linux 系统中常见的块设备有如硬盘、软驱等等。
网络设备:网络设备既可以是网卡这样的硬件设备,也可以是一个纯软件设备如回环设
备。网络设备由 Linux 的网络子系统驱动,负责数据包的发送和接收,而不是面向流设备,
因此在 Linux 系统文件系统中网络设备没有节点。
对网络设备的访问是通过 socket 调用产生,
而不是普通的文件操作如 open/close 和 read/write 等。


当前运行系统占用了哪些主设备号,可通过查看
/proc/devices 文件得到。例如:
[root@zlg /]# cat /proc/devices


获取和释放设备编号
在建立一个设备节点之前,驱动程序首先应当为这个设备获得一个可用的设备号,注销
设备需要释放所占用的设备号。设备号的生命周期是从设备注册到设备注销,在此期间,所
占用的设备号不能被其它驱动使用。Linux 内核支持静态获取和动态获取设备号,下面以字
符设备为例讲述设备号的获取与释放。
(1)静态获取主设备号
静态设备号的方式适用于下列情况:
1) 该驱动只在特定系统运行,且系统设备号使用情况明确;
2) 系统应用所要求;如为了快速启动等。
如果要从系统获得几个或者几个既定的主设备号,可用 register_chrdev_region 函数来获
取。该函数在<linux/fs.h>中声明,函数定义如下:
int register_chrdev_region(dev_t first,unsigned int count,char *name);
这个函数可以向系统注册 1 个或者多个主设备号,first 是起始编号,count 是主设备号
的数量,name 则是设备名称。注册成功返回 0,否则返回错误码。



动态获取主设备号
如果事先不知道设备的设备号,或者一个驱动可能在多个系统上运行,为了避免出现设
备号冲突,必须采用动态设备号。调用 alloc_chrdev_region 函数可以从系统获得一个或者多
个主设备号。alloc_chrdev_region 函数在<linux/fs.h>中定义:
alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
alloc_chrdev_region 函数可以从系统动态获得一个或者多个主设备号。dev 用于保存已
经获得的编号范围的第一个值,firstminor 是第一个次设备号,通常是 0,count 是获得的编
号数量,name 是设备名称。
动态获取得到的设备号,一定要用一个全局变量保存下来,以便卸载使用,否则该设备
号将不能被释放。


释放设备号
在设备注销的时候必须释放占用的主设备号,调用 unregister_chrdev_region 可以释放设
备号。函数原型:
void unregister_chrdev_region(dev_t from, unsigned count);



支持 udev 设备管理方法
Linux 2.6 引入了动态设备管理,用 udev 作为设备管理器,相比之前的静态设备管理,
在使用上更加方便灵活。udev 根据 sysfs 系统提供的设备信息实现对/dev 目录下设备节点的
动态管理,包括设备节点的创建、删除等
若要编写一个能用 udev 管理的设备驱动,需要在驱动代码中调用 class_create()为设备
创建一个 class 类,再调用 device_create()为每个设备创建对应的设备。
class_create()函数用于在 sysfs 的 class 目录下创建一个类

与 class_create()对应的销毁函数是 class_destroy()


ioctl 系统调用主要用于增加系统调用的硬件控制能力,它可以构建自己的命令,也能接
受参数。通过 ioctl 控制硬件 I/O,必须在驱动中为 ioctl()系统调用设计一些控制命令,通过
不同的命令实现不同的硬件控制

检查地址的合法性
与用户空间交换数据有几组函数,无论用什么函数,都必须隐式或者显式的检查空间的
合法性,通过 access_ok()完成。有些函数已经在内部完成了空间验证,带“__”的函数则要
求程序编写者自行进行验证。
access_ok()函数仅仅用于验证某段空间能否被读写,而不进行数据传输:































