1. 词条 POSIX
POSIX 是 Portable Operating System Interface 的缩写,表示可移植操作系统接
口,它规定了操作系统应该为应用编程提供的接口标准。

2. Linux 内核的重要特点
Linux 是一个开放自由的操作系统内核,具有一些鲜明的特点:
(1) Linux 是一个一体化内核;
注:
“一体化内核”是也称“宏内核”
,是相对于“微内核”而言的。几乎所有
的嵌入式和实时系统都采用微内核,如 VxWorks、uC/OS-II、PSOS 等。
(2) 可移植性强。尽管 Linus 最初只为在 X86 PC 上实现一个“类 UNIX”,后来随
着加入者的努力,Linux 目前已经成为支持硬件平台最广泛的操作系统;
注:目前已经在 X86、IA64、ARM、MIPS、AVR32、M68K、S390、Blackfin、M32R
等众多架构处理器上运行。
(3) 是一个可裁剪操作系统内核。Linux 极具伸缩性,内核可以任意裁剪,可以大至
几十或者上百兆,可以小至几百 K,运行的设备从超级计算机、大型服务器到
小型嵌入式系统、掌上移动设备或者嵌入式模块,都可以运行;
(4) 模块化。Linux 内核采用模块化设计,很多功能模块都可以编译为模块,可以在
内核运行中动态加载/卸载而无需重启系统;
(5) 网络支持完善。Linux 内核集成了完整的 POSIX 网络协议栈,网络功能完善;
(6) 稳定性强。运行 Linux 的内核的服务器可以做到几年不用复位重启;
4广州致远电子股份有限公司(www.zlg.cn)/广州周立功单片机科技有限公司(www.zlgmcu.com)
(7) 安全性好。Linux 源码开放,由众多黑客参与 Linux 的开发,一旦发现漏洞都能
及时修复;
(8) 支持的设备广泛。Linux 源码中,设备驱动源码占了很大比例,几乎能支持任何
常见设备,无论是很老旧的设备还是最新推出的硬件设备,几乎都能找到 Linux
下的驱动。

3. Linux 内核由 5 个主要子系统组成,分别是:内存管理、进程管理、进程间通信、虚拟
文件系统和网络

进程管理
进程管理负责控制进程对 CPU 的访问,如任务的创建、调度和终止等。任务调度是进
程管理最核心的工作,由 Linux 内核调度器来完成。Linux 内核调度器根据一定算法来选择
最值得运行的进程。


一个进程的可能状态有如下几种:
(1) 运行态——已经获得了资源,并且进程正在被 CPU 执行。进程既可运行在内核
态,也可运行在用户态。
 内核态,内核和驱动所运行时的状态,程序处于特权阶级,能够访问系统的任
何资源,好比社会的统治者。
 用户态,用户程序运行的状态,处于非特权阶级,不能随意访问系统资源,必
须通过驱动程序方可访问,用户态程序可通过系统调用进入内核态。用户态程
序有如社会的被统治者,处于被管理的非特权阶级,只有通过某种途径才能进
入特权阶级。
(2) 就绪态——当系统资源已经可用,但由于前一个进程还没有执行完而释放 CPU,
准备进入运行状态。
(3) 可中断睡眠状态——当进程处于可中断等待状态时,系统不会调度该程序执行。
当系统产生一个中断或者释放了进程正在等待的资源,或者进程收到一个信号,
都可以被唤醒进入就绪状态或者运行态。
(4) 不可中断睡眠状态——处于中断等待状态,但是该进程只能被使用 wake_up()
函数明确唤醒的时候才可进入就绪状态。
(5) 暂停状态——当进程收到 SIGSTOP、SIGSTP、SIGTTIN 或者 SIGTTOU 就会进
入暂停状态,收到 SIGCONT 信号即可进入运行态。
(6) 僵死态——进程已经停止运行,但是其父进程还没有询问其状态。


进程和状态的转换有点抽象,用生活中一个比较接近的例子类比一下,或许能有助于理
解。Linux 内核调度器好比是生产线的主管,而进程则好比是生产线上的工人。主管 24 小
时不间断的工作,工人的工作时间是朝九晚五,其余时间在等待区排队等候。
早上工人到达工厂,还没到 9 点上班时间,工人可以在等待区休息,这个状态可以称之
为“就绪态”
;但是 9 点一到,工人则必须上生产线工作,这个工作状态可称之为“运行态”
;
下午 5 点一到,到了工人下班时间,工人离开生产线又回到等待区排队等候,处于“就绪态”
。
如果工人上班的时候,收到主管的命令,说是“你暂时不用工作了,到休息室休息等待”
,
工人此时的这个状态,可以称之为“暂停”状态,过了一段时间,主管通知工人说是“休息
结束,要准备工作了”
,工人不能直接回生产线岗位,而是必须先到等待区排队等待,轮到
后才上生产线工作。
如果有一天工人精神状态不好,向主管申请要睡觉休息,理由可以是“某种配件不到,
我无法工作”
,也可以是“我就是困了,想睡觉”
,工人最后可能得到两种批准结果:一是主
管批准了,但是附加了一个条件说“等我叫醒你,你必须醒来上班”,然后工人就去享受他
的安稳觉了,工人进入“不可中断睡眠”状态;另一种是主管也批准了,但是附加了另一个
条件,说“在你睡觉的时候,如果配件到了,你就得立马给我起来上班”,工人也去睡觉去
了,但此时工人睡得并不安心,因为这不是一个安稳觉,是“可中断睡眠”
。无论工人睡得
是安稳觉,还是不安稳觉,醒来都不能直接上生产线,而是回到等待区,等待轮值。
还有一种情况,工人干完活到点下班了,但主管对他不闻不问,也不安排新的工作,这
是一种非正常状况,工人进入了“僵死态”。


内存管理
内存管理的主要作用是控制和管理多个进程,使之能够安全的共享主内存区域。当 CPU
提供内存管理单元(MMU)时,内存管理为各进程实现虚拟地址到内存物理地址的转换。
在 32 位系统上, Linux 内核将 4G 空间分为 1G 内核空间(3~4G)和 3G(0~3G)用户空间,
通过内存管理,每个进程都可以使用 3G 的用户空间。



文件系统
Linux 内核支持众多的逻辑文件系统,如 Ext2、Ext3、Ext4、btrfs、NFS、VFAT 等。
VFS 则是 Linux 基于各种逻辑文件系统抽象出的一种内存中的文件系统,隐藏了各种硬件设
备细节,为用户提供统一的操作接口,是用户访问各种不同文件系统和设备时,不用区分具
体的逻辑文件系统。例如,Linux 下硬盘上使用的文件系统通常是 Ext3/4 格式,而 U 盘通常
是 FAT32 格式,但是用户在使用中根本感觉不到差异,也不用区分文件系统的具体差别。
4. 网络接口
Linux 对网络支持相当完善,网络接口提供了对各种网络标准的存取和各种网络硬件的
支持,接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输
协议。网络设备驱动程序负责与硬件设备通讯,每一种可能的硬件设备都有相应的设备驱动
程序。


进程间通信
支持进程间各种通信机制,如管道、命名管道、信号、消息队列、内存共享、信号量和
套接字等。
 管道通常用于具有亲缘关系的父子进程或者兄弟进程间通信,是半双工的,数据只
能往一个方向流动,先入先出,与自来水管很相似。如果双方互通时,需要建立两
个管道。
 命名管道则突破了进程间的亲缘关系限制,即非父子、兄弟进程之间也可相互通信。
 信号是软件中断,用于在多个进程之间传递异步信号。日常生活中信号的例子很多
了,如一对很亲密的哑巴情侣,在很多时候只需要一个简单的眼神,对方就能知道
他(她)需要什么,并做出回应,这个眼神,就是一个“信号”。
 信号能传递的信息有限,而消息队列则正好弥补了这点。例如情侣的一个眼神,对
方可能能知道情侣的需求,但是如果情侣有一大堆需求,仅仅靠一个眼神就比较费
力了。情侣就把自己的需求写在了一张纸条上,递交给对方,对方根据纸条的内容,
逐一满足情侣的需求。
 共享内存常用于不同进程间进行大量数据传递。Linux 下每个进程都有自己的独立
空间,各自都不能直接访问其它进程的空间。好比这对情侣都有自己的小金库,有
时候需要给对方一部分钱用,但他们不能直接相互转账,必须先将前存到他们俩合
开的一个公共账户上面,然后再使用。这个公共账户就是这对情侣的“共享内存”
。
 信号量用于进程同步。只有获得了信号量的进程才可以运行,没有获得信号量的进
程则只能等待。就像十字路口的红绿灯,只有在绿灯亮(获得了绿灯)的时候才能
通行,否则只能等待。
 套接字(Socket)起源于 BSD,也常称“BSD 套接字”
,用于多个进程间通信,可以
基于文件,也可基于网络。Socket 本意是“插座”,套接字设计就是通过某些参数
设定,然后将一个“插座”与另外一个“插座”连接起来。可能还有点抽象,看一
个例子可能就好理解了。把套接字理解为固定电话的插口,现在要打电话出去,必
须要知道打给谁,往哪里打;另外电话另一端必须有人在听才可以通话,否则也不
能打电话。




4.
嵌入式 Linux 是对运行在嵌入式设备上的 Linux 的统称,严格说来,每种不同应用的嵌
入式 Linux 都可以称为是一个发行版。嵌入式 Linux 往往针对于某个特殊领域,专门为实现
某些特定的功能而开发,一般说来,嵌入式 Linux 所运行的程序相对来说比较单一,功能定
位也比较明确,如嵌入式网关、路由器等

将标准 Linux 应用到嵌入式领域,往往是根据实际需要裁减内核,内核一般从几百 K
到几兆字节不等。所使用的文件系统也不是桌面 Linux 这样复杂庞大的软件包,一般也是用
源码或者其它工具定制,文件系统的大小也可以从几兆到几十兆,或者上百兆不等。
Linux 在嵌入式领域的分化,一般是两个方向,小型化和实时化。
小型化一般就是根据需要将不需要的功能和服务去掉,尽可能的减小内核和系统的体积,
以节省硬件资源和成本,如 ETLinux、uLinux、ThinLinux 等。
实时化一般是通过修改源代码,为 Linux 内核增加比校准内核更好的实时性,以满足一
些对实时性有要求的特定领域的应用,如 RTLinux、RTAI 等。

5.
无论最终产品以何种形态出现,在开发阶段,串口和网口几乎是必不可缺的外设接口。
嵌入式 Linux 的默认终端通常是调试串口,系统输出信息通过串口输出,也通过串口接收各
种命令。而网口则常用于数据传输和程序调试,特别是在内核开发阶段以及应用程序开发阶
段,网络几乎也是必须的。

6.
$chmod +x a.sh
$./a.sh
执行 Shell 脚本有多种方式:
(1)点+斜线+文件名,这种方式要求文件必须有可执行权限

7.
交叉编译
由于嵌入式系统资源匮乏,一般不能像 PC 一样安装本地编译器和调试器,不能在本地
编写、编译和调试自身运行的程序,而需借助其它系统如 PC 来完成这些工作,这样的系统
通常被称为宿主机。
宿主机通常是 Linux 系统,并安装交叉编译器、调试器等工具;宿主机也可以是 Windows
系统,安装嵌入式 Linux 集成开发环境。在宿主机上编写和编译代码,通过串口、网口或者
硬件调试器将程序下载到目标系统里面运行

所谓的交叉编译,就是在宿主机平台上使用某种特定的交叉编译器,为某种与宿主机不
同平台的目标系统编译程序,得到的程序在目标系统上运行而非在宿主机本地运行。这里的
平台包含两层含义:一是核心处理器的架构,二是所运行的系统,这样,交叉编译有 3 种情
形:
(1) 目标系统与宿主机处理器相同,运行不同的系统;
(2) 目标系统与宿主机处理器不同,运行相同的系统;
(3) 目标系统与宿主机处理器不同,运行不同的系统


实际上,在 PC 上进行非 Linux 的嵌入式开发,哪怕使用 IDE 集成环境如 Keil、ADS、
Realview,都是交叉编译和调试的过程,只是 IDE 工具隐藏了细节,没有明确提出这个概念
而已。

交叉编译器
交叉编译器是在宿主机上运行的编译器,但是编译后得到的二进制程序却不能在宿主机
上运行,而只能在目标机上运行。交叉编译器命名方式一般遵循“处理器-系统-gcc”这样的
规则,一般通过名称便可以知道交叉编译器的功能。例如下列交叉编译器:
 arm-none-eabi-gcc,
表示目标处理器是 ARM,
不运行操作系统,
仅运行前后台程序;
 arm-uclinuxeabi-gcc,表示目标处理器是 ARM,运行 uClinux 操作系统;
 arm-none-linux-gnueabi-gcc,表示目标处理器是 ARM,运行 Linux 操作系统;
 mips-linux-gnu-gcc,表示目标处理器是 MIPS,运行 Linux 操作系统。
进行 ARM Linux 开发,通常选择 arm-linux-gcc 交叉编译器。ARM-Linux 交叉编译器可
以自行从源代码编译,也可以从第三方获取。在能从第三方获取交叉编译器的情况下,请尽
量采用第三方编译器而不要自行编译,一是编译过程繁琐,不能保证成功,二是就算编译成
功,也不能保证交叉编译器的稳定性,编译器的不稳定性会对后续的开发带来无限隐患。而
第三方提供的交叉编译器通常都经过比较完善的测试,确认是稳定可靠的。


8.
“Vi+Gcc+Make+GDB”这一组“黄
金搭档”
,它们是 Linux 世界编程的经典组合。这个组合的推出,既能替“选择困难症”者
做决定性选择,也能有效防止“病急乱投医”。


对于一些大型程序,在 IDE 环境中编程,或许能带来更多好处,为此,也介绍了
一个在 Linux 世界几乎“无所不能”的 IDE——Eclipse

gcc 主要软件包
cpp C 预处理器
gcc C 编译器
g++ C++编译器
gccbug 创建 BUG 报告的 Shell 脚本
gcov 覆盖测试工具,用于分析程序哪里做优化效果最佳
libgcc GCC 的运行库
libstdc++ 标准 C++库
libsupc++ 提供支持 C++语言的函数库


9. 
64位Ubuntu 16.04搭建嵌入式交叉编译环境arm-linux-gcc过程图解
https://www.linuxidc.com/Linux/2016-12/138771.htm


10.
Board Support Package顾名思义，就是板级支持包，说白了就是最底层底层的驱动+与某种操作系统的接口。
学过单片机或arm的都知道驱动，如果这些驱动能够支持某种操作系统（如linux）运行在这个板子上，
那么就说他是这个操作系统在这个板子上的bsp。比如你编译不同版本嵌入式linux操作系统时，低的版本可能只支持到2410,2440，
高的支持到6410板子以上，通用的linux已经根据一定标准把流行的几种的硬件板子的bsp都做好了，所以不用开发bsp，
但是特殊的板子或者特殊的需求（比如有的功能需要绕开操作系统做到最底层）都需要开发bsp，没有它操作系统运行不了。

BSP相当于硬件驱动，完成初始化、时钟、中断、串口、网络、flash等的设备驱动。
BootLoader用于加载、调试程序。

不同的CPU具有不同的启动方式，其系统外设等均具有较大的差异。CPU上电启动后，并不具有相应的内核启动环境，
需要bootloader先初始化CPU及相应系统外设，加载内核，使之具备内核启动的必要条件。bootloader一般应有下载固化以及加载启动这两个功能，



11.Linux多线程编程c

线程（thread）是包含在进程内部的顺序执行流，是进程中的实际运作单位，也是操作系统能够进行调度的最小单位。一个进程中可以并发多条线程，每条线程并行执行不同的任务。
线程与进的关系
线程与进程的关系可以归结于以下几点：
 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主； 一个线程只能属于进，而可以有多但至少主；
 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该； 资源分配给进程，同一的所有线共享该；
 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源； 线程作为调度和分配的基本单位，进拥有资源；
 进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于进程是拥有资源的 一个独立单位，线不系统但可以访问隶属于资源；
 在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大在创 建或撤消进程时，由于系统都要为之分配和回收资源导致的开销大建或撤消线程时的开销。 建或撤消线程时的开销。 建或撤消线程时的开销。 建或撤消线程时的开销。


POSIX Threads（通常简称为Pthreads）定义了创建和操纵线程的一套API接口，一般用于Unix-like POSIX 系统中（如FreeBSD、GNU/Linux、OpenBSD、Mac OS等系统）

Pthreads接口可以根据功能划分四个组：
 线程管理 线程管理
 互斥量
 条件变量 条件变量
 同步
编写Pthreads多线程程序时源码只需包含pthread.h头文件就可以使用Pthreads库中的所有类型及函数： #include <pthread.h>

LDFLDF += -pthread




pthread_t pthread_self(void); //线程可以通过调用pthread_self()函数来获取自己的ID

int pthread_equal(pthread_t t1, pthread_t t2); //由于pthread_t类型可能是一个结构体，可以使用pthread_equal()来比较两个线程ID是否相等。


int pthread_create(pthread_t *thread, const pthread_attr_t * attr, void*(*start_routine)(void*),void *arg); //创建一个新线程的函数是pthread_create()

参数说明：
 threadthread thread 用指向新创建的 线程用指向新创建的 线程用指向新创建的 线程用指向新创建的 线程用指向新创建的 线程ID ；
 attr attrattr用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 用来表示一个封装了线程各种属性的对象，如果 attr attrattr为 NULLNULLNULLNULL，新线程就 使用默认的属性， 使用默认的属性， 使用默认的属性， 使用默认的属性， 13.3.4 13.3.4 节将讨论线程属性的细； 节将讨论线程属性的细； 节将讨论线程属性的细； 节将讨论线程属性的细； 节将讨论线程属性的细； 节将讨论线程属性的细；
 start_routine start_routine start_routinestart_routine start_routine start_routinestart_routine 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， 是线程开始执行的时候调用函数名字， start_routine start_routine start_routinestart_routine start_routine start_routinestart_routine 函数有 一个函数有 一个函数有 一个函数有 一个指向 voidvoid void的指针参数，并有 的指针参数，并有 的指针参数，并有 的指针参数，并有 的指针参数，并有 pthread_crea pthread_crea pthread_crea pthread_crea pthread_crea te 的第四个参数 的第四个参数 的第四个参数 的第四个参数 arg arg指定值，同时 指定值，同时 指定值，同时 start_routine start_routine start_routinestart_routine start_routine start_routinestart_routine 函数返回一个指向 函数返回一个指向 函数返回一个指向 函数返回一个指向 voidvoid void的指针，这个返回值被 的指针，这个返回值被 的指针，这个返回值被 的指针，这个返回值被 的指针，这个返回值被 的指针，这个返回值被 pthread_join pthread_join pthread_join pthread_join pthread_join当做退出 当做退出 当做退出 状态处理， 状态处理， 13.3.3 13.3.3节介绍线程的退出状态； 节介绍线程的退出状态； 节介绍线程的退出状态； 节介绍线程的退出状态； 节介绍线程的退出状态； 节介绍线程的退出状态；
 arg arg为参数 为参数 start_routine start_routine start_routinestart_routine start_routine start_routinestart_routine 指定函数的参。 指定函数的参。 指定函数的参。


void pthread_exit(void* retval);
//调用exit()函数会使整个进程终止，而调用pthread_exit()只会使得调用线程终止，同时在创建的线程的顶层执行return线程会隐式地调用pthread_exit()


连接与分离
线程可以分为分离线程(DETACHED)和非分离线程(JOINABLE)两种：
 分离线程是指线程退出时线程将释放它的资源的线程；
 非分离线程退出后不会立即释放资源，需要另一个线程为它调用pthread_join函数或者进程退出时才会释放资源。
只有非分离线程才是可连接的，而分离线程退出时不会报告线程的退出状态。

int pthread_detach(pthread_t thread); // pthread_detach()函数可以将非分离线程设置为分离线程
pthread_detach(pthread_self());   //线程可以自己来设置分离，也可以由其它线程来设置分离，以下代码线程可设置自身分离


int  pthread_join(pthread_t thread,void** retval); //如果一个线程是非分离线程，那么其它线程可调用pthread_join()函数对非分离线程进行连接

int pthread_attr_init(pthread_attr_t *attr); //函数用于将属性对象使默认值进行初始化，认值进行初始化，
int pthread_attr_destroy(pthread_attr_t *attr);   //销毁属性对象使用 

int pthread_attr_getdetachstate(pthread_attr_t *attr, int* detachstate);  //获取线程状态
int pthread_attr_setdetachstate(pthread_attr_t * attr, int detachestate);  //设置线程状态

int pthread_attr_getstacksize(pthread_attr_t,, size_t*stacksize);
int pthread_attr_setstacksize(pthread_attr_t * attr, size_t stacksize);

int pthread_attr_getdetachstate(pthread_attr_t* attr, int* detachstate);
int pthread_attr_setdetachstate(pthread_attr_t* attr, int detachstate);

12. NFS配置

ls
https://blog.csdn.net/czcdcdsn/article/details/78996412

#/etc/init.d/nfs-kernel-server start    //方法一


在Virtual Host上测试NFS服务
	在Virtual Host 的终端中输入“cd /home/nfs”进入NFS服务的共享目录，然后输入命令“mkdir a b c d”在NFS服务的共享目录下创建a、b、c、d四个空目录，
	
	使用“mkdir -p /mnt/nfs_test”命令创建NFS服务的共享目录的测试挂载点目录，这时使用命令“ls /mnt/nfs_test”查看挂载点目录为空。
	在Virtual Host 的终端中输入“ifconfig eth0 ”查看Virtual Host 的IP地址（当前Virtual Host 的IP为192.168.1.110）。
	在Virtual Host的终端中输入命令“mount -t nfs 192.168.1.110:/home/nfs /mnt/nfs_test -o nolock” ，
	将Virtual Host 上NFS服务共享的目录挂载到Virtual Host 的测试挂载点/mnt/nfs_test上，这时使用命令“ls /mnt/nfs_test”查看挂载点目录，内容与/home/nfs相同



在Target Board的终端中输入命令“mount -t nfs 172.20.4.101:/home/nfs /mnt -o nolock”，
将virtual Host上的NFS共享目录挂载到Target Board的/mnt上。在Target Board的/mnt/目录下可以看到readme.txt文件


steps:

1. arm-fsl-linux-gnueabi-gcc hello.c -o hello
2. sudo cp hello /home/nfs/





































